"use strict";(self.webpackChunklh_site=self.webpackChunklh_site||[]).push([[2558],{6720:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var s=n(4848),a=n(8453);const i={slug:"transactional-outbox",authors:["coltmcnealy"],tags:["analysis","integration-patterns","littlehorse"]},r="Integration Patterns: Transactional Outbox",o={permalink:"/blog/transactional-outbox",source:"@site/blog/2024-09-30-transactional-outbox.md",title:"Integration Patterns: Transactional Outbox",description:"Like the Saga Pattern, the Transactional Outbox pattern is tool for defending against data loss in your applications. In this blog we cover how it works and how to do it easier using LittleHorse.",date:"2024-09-30T00:00:00.000Z",tags:[{inline:!1,label:"Technical Analysis",permalink:"/blog/tags/analysis/",description:"Analysis of the current and future state of Technical Architecture."},{inline:!1,label:"Integration Patterns",permalink:"/blog/tags/integration-patterns/",description:"A 5-part blog series on Integration Patterns that are useful for event-driven systems."},{inline:!1,label:"LittleHorse Orchestrator",permalink:"/blog/tags/littlehorse/",description:"Information about the LittleHorse Orchestrator."}],readingTime:5.74,hasTruncateMarker:!0,authors:[{name:"Colt McNealy",title:"Managing Member of the LLC",description:"Colt is the founder of LittleHorse Enterprises and the original author of the LittleHorse Orchestrator. He's a passionate Apache Kafka fan and loves hockey, golf, piano, cooking, and Taekwondo.",page:{permalink:"/blog/authors/coltmcnealy"},socials:{github:"https://github.com/coltmcnealy-lh",linkedin:"https://www.linkedin.com/in/colt-mcnealy-900b7a148/",x:"https://x.com/coltmcnealy"},imageURL:"https://avatars.githubusercontent.com/u/100447728",key:"coltmcnealy"}],frontMatter:{slug:"transactional-outbox",authors:["coltmcnealy"],tags:["analysis","integration-patterns","littlehorse"]},unlisted:!1,nextItem:{title:"Integration Patterns: Saga Transactions",permalink:"/blog/saga-pattern"}},l={authorsImageUrls:[void 0]},c=[{value:"The Transactional Outbox Pattern",id:"the-transactional-outbox-pattern",level:2},{value:"Case Study: Customer Sign-Up",id:"case-study-customer-sign-up",level:2},{value:"Using a Transactional Outbox",id:"using-a-transactional-outbox",level:3},{value:"Using LittleHorse",id:"using-littlehorse",level:3},{value:"Wrapping Up",id:"wrapping-up",level:2},{value:"Additional Use Cases",id:"additional-use-cases",level:3},{value:"Alternative: Log-First Architecture",id:"alternative-log-first-architecture",level:3},{value:"Get Involved!",id:"get-involved",level:3}];function h(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["Like the ",(0,s.jsx)(t.a,{href:"/blog/saga-pattern",children:"Saga Pattern"}),", the Transactional Outbox pattern is tool for defending against data loss in your applications. In this blog we cover how it works and how to do it ",(0,s.jsx)(t.em,{children:"easier"})," using LittleHorse."]}),"\n",(0,s.jsxs)(t.admonition,{type:"info",children:[(0,s.jsx)(t.p,{children:"This is the first part in a five-part blog series on useful Integration Patterns. This blog series will help you build real-time, responsive applications and microservices that produce predictable results and prevent the Grumpy Customer Problem."}),(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"/blog/saga-pattern",children:"Saga Transactions"})}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"[This Post]"})," The Transactional Outbox Pattern"]}),"\n",(0,s.jsx)(t.li,{children:"[Coming soon] Queuing and Backpressure"}),"\n",(0,s.jsx)(t.li,{children:"[Coming soon] Retries and Dead-Letter Queues"}),"\n",(0,s.jsx)(t.li,{children:"[Coming soon] Callbacks and External Events"}),"\n"]})]}),"\n",(0,s.jsx)(t.h2,{id:"the-transactional-outbox-pattern",children:"The Transactional Outbox Pattern"}),"\n",(0,s.jsxs)(t.p,{children:["At the technical level, the ",(0,s.jsx)(t.a,{href:"https://microservices.io/patterns/data/transactional-outbox.html",children:"Transactional Outbox Pattern"})," allows you to atomically:"]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Update a database, and"}),"\n",(0,s.jsx)(t.li,{children:"Publish a record to a streaming log or message queue (such as Apache Kafka)."}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.a,{href:"/blog/saga-pattern",children:"Saga Pattern"})," allows you to make a multi-step business process atomic. However, you can think of the Transactional Outbox pattern as a way to ensure that a process doesn't get dropped halfway through."]}),"\n",(0,s.jsxs)(t.admonition,{type:"tip",children:[(0,s.jsxs)(t.p,{children:["The Transactional Outbox Pattern is often useful ",(0,s.jsx)(t.em,{children:"within"})," a Saga transaction."]}),(0,s.jsx)(t.p,{children:"However, as we'll see later on in this article, LittleHorse removes the need to worry about such difficult technical details."})]}),"\n",(0,s.jsx)(t.h2,{id:"case-study-customer-sign-up",children:"Case Study: Customer Sign-Up"}),"\n",(0,s.jsxs)(t.p,{children:["As an example, let's consider the following Spring Boot REST endpoint (",(0,s.jsx)(t.code,{children:"POST /user"}),"), which must:"]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Create a customer account in a database."}),"\n",(0,s.jsx)(t.li,{children:"Send a message on a queue which results in a series of account setup actions, including a welcome email being sent to the customer."}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'@PostMapping("/user")\npublic ResponseEntity<String> createUser(@RequestBody CreateUserRequest request) {\n    database.createUser(request);\n    queue.publishUserCreatedEvent(request);\n    return ResponseEntity.status(HttpStatus.CREATED);\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["A few things can go wrong here which would cause the user to be created in the database but the customer never gets a welcome email, and the account setup fails. First, the queue could be inaccessible (this ",(0,s.jsx)(t.em,{children:"could"})," be saved at the application layer with an exception handler)."]}),"\n",(0,s.jsxs)(t.p,{children:["However, one failure mode which ",(0,s.jsx)(t.em,{children:"cannot"})," be caught at the application layer is if the Spring Boot app crashes during the process of publishing the record to the queue (on or just before the ",(0,s.jsx)(t.code,{children:"queue.publishUserCreatedEvent()"})," line)."]}),"\n",(0,s.jsx)(t.p,{children:"This would definitely cause another case of the Grumpy Customer Problem!"}),"\n",(0,s.jsx)(t.h3,{id:"using-a-transactional-outbox",children:"Using a Transactional Outbox"}),"\n",(0,s.jsx)(t.p,{children:"The core idea of a Transactional Outbox is to make use of transactions within a single database to atomically:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Make the database update."}),"\n",(0,s.jsxs)(t.li,{children:["Write the desired queue event to an ",(0,s.jsx)(t.em,{children:"Outbox Table."})]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Transactional Outbox Architecture",src:n(1888).A+"",width:"3631",height:"1623"})}),"\n",(0,s.jsxs)(t.p,{children:["Since items ",(0,s.jsx)(t.code,{children:"1"})," and ",(0,s.jsx)(t.code,{children:"2"})," happen within a single database, it's trivial to wrap them in a transaction. After the queue event is written to the Outbox Table, a separate process eventually reads the new records in the Outbox Table and pushes them to a queue."]}),"\n",(0,s.jsx)(t.p,{children:"We would rewrite our Spring Boot endpoint to only write a transaction to the database. The SQL for that transaction would look something like:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"BEGIN TRANSACTION;\nINSERT INTO user VALUES ...;\nINSERT INTO outbox VALUES ...; # Insert the record for the queue\nCOMMIT;\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The Spring Boot application should have another thread which reads records from the ",(0,s.jsx)(t.code,{children:"outbox"}),' table, publishes them to the queue or streaming system, and updates the record in the database as "read".']}),"\n",(0,s.jsxs)(t.admonition,{type:"warning",children:[(0,s.jsx)(t.p,{children:"The topic of Exactly-Once Semantics is complex; we do not have time in this post to discuss the implications of EOS and a Transactional Outbox."}),(0,s.jsxs)(t.p,{children:['As a hint, you can achieve EOS if you transactionally store the last-written offset inside your message broker. There are many "gotchas" to this depending on your message broker; for example, in Apache Kafka you must use ',(0,s.jsx)(t.code,{children:"read_committed"})," consumers."]})]}),"\n",(0,s.jsx)(t.h3,{id:"using-littlehorse",children:"Using LittleHorse"}),"\n",(0,s.jsx)(t.p,{children:'The Outbox Pattern is necessary to persist outgoing records in the case that we suffer a crash between writing to the database and writing to the record queue. However, what if we could "delegate" persistence and reliability to some other system?'}),"\n",(0,s.jsxs)(t.p,{children:["Enter LittleHorse! What if we had a ",(0,s.jsx)(t.code,{children:"WfSpec"})," that defined our process, as follows:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'public void wfLogic(WorkflowThread wf) {\n    var userRequest = wf.addVariable("create-user-request", JSON_OBJ).required();\n    wf.execute("create-user", userRequst);\n    wf.execute("send-welcome-email", user);\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"Now, all our REST endpoint has to do is run the worklfow:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'@PostMapping("/user")\npublic ResponseEntity<String> createUser(@RequestBody CreateUserRequest request) {\n    // Just run the workflow\n    littlehorseClient.runWf(RunWfRequest.newBuilder()\n        .setWfSpecName("user-workflow")\n        .putVariables("create-user-request", LHLibUtil.objToVarVal(request))\n        .build());\n    return ResponseEntity.status(HttpStatus.CREATED);\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Transactional Outbox Architecture with LittleHorse",src:n(6118).A+"",width:"1970",height:"1485"})}),"\n",(0,s.jsxs)(t.p,{children:["No outbox table needed! If creating the user in the database fails, or if sending the welcome email fails, LittleHorse will patiently retry (according to your retry backoff policy) the ",(0,s.jsx)(t.code,{children:"TaskRun"}),"s until they succeed. In the event that you exhaust your retries, you still haven't lost data:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"You can easily search for failed workflows."}),"\n",(0,s.jsxs)(t.li,{children:["You can restart failed workflows with the ",(0,s.jsx)(t.code,{children:"rpc RescueThreadRun"})," once the database incident is resolved."]}),"\n"]}),"\n",(0,s.jsxs)(t.admonition,{type:"tip",children:[(0,s.jsxs)(t.p,{children:["You can add retries using the ",(0,s.jsx)(t.code,{children:"Workflow"})," object:"]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'Workflow wf = Workflow.newWorkflow("user-workflow", this::wfLogic);\nwf.setDefaultTaskRetries(10);\nwf.setDefaultTaskExponentialBackoffPolicy(ExponentialBackoffRetryPolicy.newBuilder()\n        .setBaseIntervalMs(1000)\n        .setMultiplier(3)\n        .build());\n\nwf.registerWfSpec(littlehorseClient);\n'})})]}),"\n",(0,s.jsx)(t.h2,{id:"wrapping-up",children:"Wrapping Up"}),"\n",(0,s.jsx)(t.p,{children:"The Transactional Outbox Pattern is a useful and often necessary tool for building reliable integrations between systems. However, it takes time, infrastructure, and deep understanding of distributed systems to get it right. So why spend time solving problems that don't differentiate your business?"}),"\n",(0,s.jsx)(t.p,{children:"Thankfully, LittleHorse offers a workaround to the original problem, removing the need to engage with the complexities of Transactional Outboxes."}),"\n",(0,s.jsx)(t.h3,{id:"additional-use-cases",children:"Additional Use Cases"}),"\n",(0,s.jsxs)(t.p,{children:["The Transactional Outbox pattern is useful anytime you need to update information in a database ",(0,s.jsx)(t.em,{children:"and also"})," publish a record to a streaming log or a message queue."]}),"\n",(0,s.jsx)(t.p,{children:"For example:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"User registration:"})," Save a new user's profile and push a message to a queue in order to trigger a verification email."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Appointment scheduling:"})," Save appointment details and notify users via SMS or email."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Saga Transactions:"})," Within a Saga transaction (such as the order processing scenario discussed in the ",(0,s.jsx)(t.a,{href:"/blog/saga-pattern#case-study-order-processing",children:"last post"}),"), a service may need to atomically update its database and push a record to a queue."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Inventory management:"})," Update stock levels and push updates to warehouses or suppliers."]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"alternative-log-first-architecture",children:"Alternative: Log-First Architecture"}),"\n",(0,s.jsx)(t.p,{children:"Another solution to this specific problem would be to have the request handler (our Spring Boot endpoint) publish directly to an event log like Apache Kafka. Then, there would be two consumer groups for that topic:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["A consumer group which creates the ",(0,s.jsx)(t.code,{children:"user"})," record in the database."]}),"\n",(0,s.jsx)(t.li,{children:"A consumer group which sends the welcome email."}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["The REST endpoint would return ",(0,s.jsx)(t.code,{children:"201"})," as soon as the record was acknowledged by the streaming platform."]}),"\n",(0,s.jsx)(t.p,{children:"If you squint hard enough, you can see that this is very similar to what happens with LittleHorse; however, using this pattern, you are responsible for wiring together a complex topology of topics and queues, which is much harder than using a workflow!"}),"\n",(0,s.jsx)(t.h3,{id:"get-involved",children:"Get Involved!"}),"\n",(0,s.jsx)(t.p,{children:"Stay tuned for the next post on Queues and Backpressure! In the meantime:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Try out our ",(0,s.jsx)(t.a,{href:"https://littlehorse.dev/docs/developer-guide/install",children:"Quickstarts"})]}),"\n",(0,s.jsxs)(t.li,{children:["Join us ",(0,s.jsx)(t.a,{href:"https://launchpass.com/littlehorsecommunity",children:"on Slack"})]}),"\n",(0,s.jsxs)(t.li,{children:["Give us a star ",(0,s.jsx)(t.a,{href:"https://github.com/littlehorse-enterprises/littlehorse",children:"on GitHub"}),"!"]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},6118:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/2024-09-30-user-workflow-lh-e7a8ae4a642a0a8d2c4ab2635ce7b445.png"},1888:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/2024-09-30user-workflow-outbox-717d91ae3fad27e1d67957580625ab19.png"},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var s=n(6540);const a={},i=s.createContext(a);function r(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);