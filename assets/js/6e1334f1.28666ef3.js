"use strict";(self.webpackChunklh_site=self.webpackChunklh_site||[]).push([[798],{8650:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var s=n(4848),i=n(8453);const r={slug:"queuing",authors:["coltmcnealy"],tags:["analysis","integration-patterns","littlehorse"]},a="Integration Patterns: Queueing",o={permalink:"/blog/queuing",source:"@site/blog/2024-10-28-queuing.md",title:"Integration Patterns: Queueing",description:"When integrating API's, we sometimes have to tie together steps that can take a long time or might not always be available. If we force the callers of our API's to wait for completion, we find ourselves with some grumpy customers. So what can we do about this?",date:"2024-10-28T00:00:00.000Z",tags:[{inline:!1,label:"Technical Analysis",permalink:"/blog/tags/analysis/",description:"Analysis of the current and future state of Technical Architecture."},{inline:!1,label:"Integration Patterns",permalink:"/blog/tags/integration-patterns/",description:"A 5-part blog series on Integration Patterns that are useful for event-driven systems."},{inline:!1,label:"LittleHorse Orchestrator",permalink:"/blog/tags/littlehorse/",description:"Information about the LittleHorse Orchestrator."}],readingTime:5.745,hasTruncateMarker:!0,authors:[{name:"Colt McNealy",title:"Managing Member of the LLC",description:"Colt is the founder of LittleHorse Enterprises and the original author of the LittleHorse Orchestrator. He's a passionate Apache Kafka fan and loves hockey, golf, piano, cooking, and Taekwondo.",page:{permalink:"/blog/authors/coltmcnealy"},socials:{github:"https://github.com/coltmcnealy-lh",linkedin:"https://www.linkedin.com/in/colt-mcnealy-900b7a148/",x:"https://x.com/coltmcnealy"},imageURL:"https://avatars.githubusercontent.com/u/100447728",key:"coltmcnealy"}],frontMatter:{slug:"queuing",authors:["coltmcnealy"],tags:["analysis","integration-patterns","littlehorse"]},unlisted:!1,nextItem:{title:"Integration Patterns: Transactional Outbox",permalink:"/blog/transactional-outbox"}},l={authorsImageUrls:[void 0]},c=[{value:"Why Queue?",id:"why-queue",level:2},{value:"Example: Reviews Application",id:"example-reviews-application",level:3},{value:"Orchestrators vs. Plain Old Queues",id:"orchestrators-vs-plain-old-queues",level:2},{value:"Monitoring and Debugging",id:"monitoring-and-debugging",level:3},{value:"Multi-Step Processes",id:"multi-step-processes",level:3},{value:"Wrapping Up",id:"wrapping-up",level:2},{value:"Get Involved!",id:"get-involved",level:3}];function h(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"When integrating API's, we sometimes have to tie together steps that can take a long time or might not always be available. If we force the callers of our API's to wait for completion, we find ourselves with some grumpy customers. So what can we do about this?"}),"\n",(0,s.jsxs)(t.admonition,{type:"info",children:[(0,s.jsx)(t.p,{children:"This is the third part in a five-part blog series on useful Integration Patterns. This blog series will help you build real-time, responsive applications and microservices that produce predictable results and prevent the Grumpy Customer Problem."}),(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"/blog/saga-pattern",children:"Saga Transactions"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"/blog/transactional-outbox",children:"The Transactional Outbox Pattern"})}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"[This Post]"})," Queuing and Backpressure"]}),"\n",(0,s.jsx)(t.li,{children:"[Coming soon] Retries and Dead-Letter Queues"}),"\n",(0,s.jsx)(t.li,{children:"[Coming soon] Callbacks and External Events"}),"\n"]})]}),"\n",(0,s.jsx)(t.h2,{id:"why-queue",children:"Why Queue?"}),"\n",(0,s.jsx)(t.p,{children:"In software architecture, simple is almost always better. With fewer moving parts, there are less chances for failure, less things to debug, and fewer pieces of infrastructure. So when and why would you introduce queues to your architecture?"}),"\n",(0,s.jsx)(t.p,{children:"Queues are useful when building services that need to accept a request from a client and then execute some processing which has any of the following characteristics:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Slow to execute."}),"\n",(0,s.jsx)(t.li,{children:"Flakey, not always-available, or in need of retries."}),"\n",(0,s.jsx)(t.li,{children:"Have a rate limit or cannot gracefully handle spikey workloads (backpressure)."}),"\n",(0,s.jsx)(t.li,{children:"Have multiple steps that need to all complete before the processing is finalized."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Crucially, if your service enqueues requests, you need to make sure that the caller of your API doesn't need to wait for their entire request to be processed: a simple promise that it will get done should be sufficient. As we will see with a practical example, this is feasible in many business cases."}),"\n",(0,s.jsx)(t.h3,{id:"example-reviews-application",children:"Example: Reviews Application"}),"\n",(0,s.jsx)(t.p,{children:"Consider a product reviews widget on an e-commerce site. In this application, users can submit reviews of a product. However, before a review can be approved to be displayed, it must first be checked for offensive content by a third-party AI service. Sometimes, this third-party service often has response times of over 10 seconds, and sometimes even goes down and is fully unavailable."}),"\n",(0,s.jsx)(t.p,{children:"A naive web app endpoint to handle this use-case might be:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'@PostMapping("/review")\npublic ResponseEntity<String> postReview(@RequestBody PostReviewRequest request) {\n\n    // Call the third-party AI service, which takes a long time and is flakey\n    try {\n        ReviewAnalysisResponse reviewAnalysis = thirdPartyService.analyzeReview(request);\n    } catch(OffensiveReviewException exn) {\n        return ResponseEntity.status(400);\n    } catch(Exception exn) {\n        return ResponseEntity.status(500);\n    }\n\n    // If we got here, the review is valid\n    reviewService.save(request);\n    return ResponseEntity.status(HttpStatus.CREATED);\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["As promised ( ","\ud83d\ude09"," ), this endpoint implementation has a sub-optimal user experience. Many times, when the flakey third-party AI service is unavailable, users will simply be unable to post reviews. Even when it is up, users will see the spinning waiting wheel for multiple seconds."]}),"\n",(0,s.jsx)(t.p,{children:"The solution? Enqueue the request for processing later by some external system, and then respond immediately to the client's request. That can be done in two ways:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Traditional Queuing:"})," simply put a record on some queue, streaming system, or event bus (such as Apache Pulsar, Apache Kafka, or AWS SQS)."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Workflow Execution:"})," tell a workflow orchestration engine like LittleHorse to start executing a process!"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Once the request is enqueued, there will be a system polling the queue to call the third-party analytics API and then either reject or approve the review. This system will be responsible for throttling requests according to the API's service limits, retrying failed messages, and waiting for the API to come back online in the case of an intermittent outage."}),"\n",(0,s.jsx)(t.h2,{id:"orchestrators-vs-plain-old-queues",children:"Orchestrators vs. Plain Old Queues"}),"\n",(0,s.jsxs)(t.p,{children:["Workflow engines ",(0,s.jsx)(t.a,{href:"/blog/basics-of-workflow",children:"internally use message queues"})," on their own! So what's the difference from the user perspective?"]}),"\n",(0,s.jsxs)(t.p,{children:["You can think of a workflow engine as a ",(0,s.jsx)(t.em,{children:"super-smart"})," message queue, with certain clear advantages over message queues including advanced monitoring and better support for multi-step processes."]}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsx)(t.p,{children:"The next post in this series will take a deep-dive into retries, idempotency, and failure handling, which is another area in which workflow engines shine above and beyond Plain Old Queues."})}),"\n",(0,s.jsx)(t.h3,{id:"monitoring-and-debugging",children:"Monitoring and Debugging"}),"\n",(0,s.jsxs)(t.p,{children:["Workflow engines provide more insight and oversight into your processes than do message queues. In our reviews application, if an angry user (",(0,s.jsx)(t.code,{children:"anakin@jeditemple.com"}),") calls customer support to complain that his review hadn't been processed in over two days, it would be tricky to find the ",(0,s.jsx)(t.em,{children:"exact"})," cause with a pure message queue."]}),"\n",(0,s.jsxs)(t.p,{children:["However, with LittleHorse, you just search for the ",(0,s.jsx)(t.code,{children:"WfRun"})," where ",(0,s.jsx)(t.code,{children:"user-id == anakin@jeditemple.com"}),":"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Dashboard Workflow Search",src:n(1659).A+"",width:"496",height:"294"})}),"\n",(0,s.jsx)(t.p,{children:"and then look on the dashboard to see what went wrong:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Dashboard Task Error Message",src:n(2767).A+"",width:"895",height:"686"})}),"\n",(0,s.jsxs)(t.p,{children:["We are also working on ",(0,s.jsx)(t.em,{children:"workflow metrics"})," that will allow you to use LittleHorse to answer questions such as:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["How long does the ",(0,s.jsx)(t.code,{children:"process-review"})," workflow take on average?"]}),"\n",(0,s.jsxs)(t.li,{children:["How long does each ",(0,s.jsx)(t.code,{children:"analyze-review"})," task attempt take on average, and what percentage of calls fail (i.e. how responsive is the API)?"]}),"\n",(0,s.jsx)(t.li,{children:"What percentage of reviews are approved versus rejected?"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"These will likely not be available until March 2025; however, we have nearly finalized the designs for them and have scheduled the implementation to start in January."}),"\n",(0,s.jsx)(t.h3,{id:"multi-step-processes",children:"Multi-Step Processes"}),"\n",(0,s.jsx)(t.p,{children:'So far, the use-case we\'ve discussed involves only two "steps" to be executed:'}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Analyze the product review."}),"\n",(0,s.jsx)(t.li,{children:"Post the review to the site."}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["You could arguably execute both steps at once: the only problem we are trying to solve is that we have a flakey API and we don't want our customers to have to wait for it. In theory, the same consumer which calls the external API could also update the visibility of the review to ",(0,s.jsx)(t.code,{children:"APPROVED"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"But what if the business requirements change, and we need to do some post-processing, such as notify a separately-managed (and also flakey) analytics service of what happened? That would require adding another queue:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Edit our original consumer to publish to a new queue."}),"\n",(0,s.jsxs)(t.li,{children:["Write a ",(0,s.jsx)(t.em,{children:"new"})," consumer that subscribes to the second queue and notifies the flakey analytics service."]}),"\n",(0,s.jsx)(t.li,{children:"Instrument monitoring for the new queue infrastructure."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"This gets especially tricky when we want to handle intermittent availability from the analytics service: we'll have to copy the same boilerplate to handle retries and dead-letter-queues (more on that in the next post)."}),"\n",(0,s.jsxs)(t.p,{children:["However, with the workflow-driven approach, all you need to do is add a single line to your ",(0,s.jsx)(t.code,{children:"WfSpec"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'wf.execute("notify-analytics-service", userId, review, approvalStatus);\n'})}),"\n",(0,s.jsx)(t.h2,{id:"wrapping-up",children:"Wrapping Up"}),"\n",(0,s.jsxs)(t.p,{children:["Queueing is a great tool to improve the client experience of your API's when you can respond to your callers before all of your processing has been done. Workflow engines like LittleHorse can actually be thought of as a ",(0,s.jsx)(t.em,{children:"super-smart queueing system"}),", which provides all of the advantages of queueing plus better observability and support for multi-step processes."]}),"\n",(0,s.jsx)(t.h3,{id:"get-involved",children:"Get Involved!"}),"\n",(0,s.jsx)(t.p,{children:"Stay tuned for the next post, which will cover retries and dead-letter queues! In the meantime:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Try out our ",(0,s.jsx)(t.a,{href:"https://littlehorse.dev/docs/developer-guide/install",children:"Quickstarts"})]}),"\n",(0,s.jsxs)(t.li,{children:["Join us ",(0,s.jsx)(t.a,{href:"https://launchpass.com/littlehorsecommunity",children:"on Slack"})]}),"\n",(0,s.jsxs)(t.li,{children:["Give us a star ",(0,s.jsx)(t.a,{href:"https://github.com/littlehorse-enterprises/littlehorse",children:"on GitHub"}),"!"]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},2767:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/2024-10-28-task-debugging-dc5d52151429b8428cfa326e57cc53d5.png"},1659:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/2024-10-28-workflow-search-6abd5f2dbb3914b3230502f28afab1f2.png"},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var s=n(6540);const i={},r=s.createContext(i);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);