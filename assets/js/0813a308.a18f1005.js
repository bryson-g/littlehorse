"use strict";(self.webpackChunklh_site=self.webpackChunklh_site||[]).push([[5837],{3905:(e,n,t)=>{t.d(n,{Zo:()=>s,kt:()=>m});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function d(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},s=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},N=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,s=d(e,["components","mdxType","originalType","parentName"]),h=p(t),N=i,m=h["".concat(l,".").concat(N)]||h[N]||u[N]||o;return t?a.createElement(m,r(r({ref:n},s),{},{components:t})):a.createElement(m,r({ref:n},s))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=N;var d={};for(var l in n)hasOwnProperty.call(n,l)&&(d[l]=n[l]);d.originalType=e,d[h]="string"==typeof e?e:i,r[1]=d;for(var p=2;p<o;p++)r[p]=t[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}N.displayName="MDXCreateElement"},6895:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>d,toc:()=>p});var a=t(7462),i=(t(7294),t(3905));const o={sidebar_label:"Nodes"},r="Node and NodeRun",d={unversionedId:"concepts/nodes",id:"concepts/nodes",title:"Node and NodeRun",description:"The LittleHorse Workflow SDK's abstract away most of the details of Nodes and NodeRuns; however, the curious reader will find this information quite interesting. If you just want to get started, you could skip this section and read the examples in the developer guide.",source:"@site/docs/04-concepts/02-nodes.md",sourceDirName:"04-concepts",slug:"/concepts/nodes",permalink:"/docs/concepts/nodes",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_label:"Nodes"},sidebar:"tutorialSidebar",previous:{title:"Workflows",permalink:"/docs/concepts/workflows"},next:{title:"Tasks",permalink:"/docs/concepts/tasks"}},l={},p=[{value:"In the API",id:"in-the-api",level:2},{value:"Edges",id:"edges",level:2},{value:"Node Types",id:"node-types",level:2},{value:"<code>ENTRYPOINT</code> Node",id:"entrypoint-node",level:3},{value:"<code>EXIT</code> Node",id:"exit-node",level:3},{value:"<code>TASK</code> Node",id:"task-node",level:3},{value:"<code>EXTERNAL_EVENT</code> Node",id:"external_event-node",level:3},{value:"<code>SPAWN_THREAD</code> Node",id:"spawn_thread-node",level:3},{value:"<code>WAIT_FOR_THREAD</code> Node",id:"wait_for_thread-node",level:3},{value:"<code>NOP</code> Node",id:"nop-node",level:3},{value:"<code>SLEEP</code> Node",id:"sleep-node",level:3},{value:"Node Outputs",id:"node-outputs",level:2},{value:"<code>TaskRun</code> Lifecycle",id:"taskrun-lifecycle",level:2}],s={toc:p},h="wrapper";function u(e){let{components:n,...t}=e;return(0,i.kt)(h,(0,a.Z)({},s,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"node-and-noderun"},(0,i.kt)("inlineCode",{parentName:"h1"},"Node")," and ",(0,i.kt)("inlineCode",{parentName:"h1"},"NodeRun")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"}," The LittleHorse Workflow SDK's abstract away most of the details of ",(0,i.kt)("inlineCode",{parentName:"p"},"Node"),"s and ",(0,i.kt)("inlineCode",{parentName:"p"},"NodeRun"),"s; however, the curious reader will find this information quite interesting. If you just want to get started, you could skip this section and read the examples in the developer guide.")),(0,i.kt)("p",null,"Just like ",(0,i.kt)("inlineCode",{parentName:"p"},"WfSpec"),"s and ",(0,i.kt)("inlineCode",{parentName:"p"},"WfRun"),"s, ",(0,i.kt)("inlineCode",{parentName:"p"},"Node"),"s and ",(0,i.kt)("inlineCode",{parentName:"p"},"NodeRun"),"s are another example of the Metadata/Execution duality in LittleHorse. A ",(0,i.kt)("inlineCode",{parentName:"p"},"Node")," is a single step in a ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadSpec"),", and a ",(0,i.kt)("inlineCode",{parentName:"p"},"NodeRun")," is a running (or already-run) instance of that ",(0,i.kt)("inlineCode",{parentName:"p"},"Node"),"."),(0,i.kt)("p",null,"If a ",(0,i.kt)("inlineCode",{parentName:"p"},"NodeRun")," fails for any reason (for example, a ",(0,i.kt)("inlineCode",{parentName:"p"},"TASK")," node times out) and there is no registered Failure Handler (see Exception Handling section), then the ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadRun")," also fails."),(0,i.kt)("h2",{id:"in-the-api"},"In the API"),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"NodeRun")," is a LittleHorse API Object. Since a ",(0,i.kt)("inlineCode",{parentName:"p"},"WfRun")," might have hundreds (or even thousands) of ",(0,i.kt)("inlineCode",{parentName:"p"},"NodeRun"),"s, the API allows you to access ",(0,i.kt)("inlineCode",{parentName:"p"},"NodeRun"),"s separately from their associated ",(0,i.kt)("inlineCode",{parentName:"p"},"WfRun"),"s."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"NodeRun")," has three-part composite ID:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"wfRunId"),", which is the ID of the associated ",(0,i.kt)("inlineCode",{parentName:"li"},"WfRun"),"."),(0,i.kt)("li",{parentName:"ol"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"threadRunNumber"),", which is the ID of the associated ",(0,i.kt)("inlineCode",{parentName:"li"},"ThreadRun"),"."),(0,i.kt)("li",{parentName:"ol"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"position"),". Each ",(0,i.kt)("inlineCode",{parentName:"li"},"ThreadRun")," consists of an ordered list of ",(0,i.kt)("inlineCode",{parentName:"li"},"NodeRun"),"s; the ",(0,i.kt)("inlineCode",{parentName:"li"},"position")," is the individual ",(0,i.kt)("inlineCode",{parentName:"li"},"NodeRun"),"'s index in that list.")),(0,i.kt)("p",null,"Note that, unlike a ",(0,i.kt)("inlineCode",{parentName:"p"},"NodeRun"),", a ",(0,i.kt)("inlineCode",{parentName:"p"},"Node")," is not an Object in the LittleHorse API. Since a ",(0,i.kt)("inlineCode",{parentName:"p"},"Node")," belongs to a ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadSpec"),", and a ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadSpec")," belongs to a ",(0,i.kt)("inlineCode",{parentName:"p"},"WfSpec"),", you can view a ",(0,i.kt)("inlineCode",{parentName:"p"},"Node")," by getting its ",(0,i.kt)("inlineCode",{parentName:"p"},"WfSpec"),"."),(0,i.kt)("h2",{id:"edges"},"Edges"),(0,i.kt)("p",null,"Each ",(0,i.kt)("inlineCode",{parentName:"p"},"Node")," in the ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadSpec")," (except for the ",(0,i.kt)("inlineCode",{parentName:"p"},"EXIT")," nodes) has a list of one or more outgoing edges."),(0,i.kt)("p",null,"When a ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadRun")," arrives at a ",(0,i.kt)("inlineCode",{parentName:"p"},"Node")," in its ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadSpec"),", a ",(0,i.kt)("inlineCode",{parentName:"p"},"NodeRun")," for that ",(0,i.kt)("inlineCode",{parentName:"p"},"Node")," is instantiated. Once the ",(0,i.kt)("inlineCode",{parentName:"p"},"NodeRun")," is completed, then the ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadRun")," advances to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Node")," pointed to by the outgoing edges."),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"NOP")," node may have more than one outgoing edge. In that case, the outgoing edges may have a Condition attached to them (see the Conditional Branching section). The first outgoing edge whos Condition evaluates to true is activaed, and the ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadRun")," advances to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Node")," pointed to by that edge."),(0,i.kt)("p",null,"Note that there are no restrictions on cycles in LittleHorse, except that a ",(0,i.kt)("inlineCode",{parentName:"p"},"Node")," may not have outgoing edges pointing directly to itself."),(0,i.kt)("h2",{id:"node-types"},"Node Types"),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"Node")," (and its associated ",(0,i.kt)("inlineCode",{parentName:"p"},"NodeRun"),") can be any of the following types. Note that when using the SDK's to build your workflows, you may not need to review this information."),(0,i.kt)("h3",{id:"entrypoint-node"},(0,i.kt)("inlineCode",{parentName:"h3"},"ENTRYPOINT")," Node"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"ENTRYPOINT")," node is equivalent to the entrypoint ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadSpec")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadRun"),". When a ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadRun")," is instantiated, it starts at the ",(0,i.kt)("inlineCode",{parentName:"p"},"ENTRYPOINT")," node and proceeds to the node pointed to by the entrypoint node's outgoing edges."),(0,i.kt)("h3",{id:"exit-node"},(0,i.kt)("inlineCode",{parentName:"h3"},"EXIT")," Node"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"EXIT")," node marks the end of a ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadSpec"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadRun"),". Noramlly, when a ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadRun")," reaches an ",(0,i.kt)("inlineCode",{parentName:"p"},"EXIT")," node, the ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadRun")," is marked as completed."),(0,i.kt)("p",null,"In many programming languages, you can explicitly ",(0,i.kt)("inlineCode",{parentName:"p"},"throw")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"raise")," an exception, which causes that thread in your program to fail. You can achieve the same effect in LittleHorse by assigning a ",(0,i.kt)("inlineCode",{parentName:"p"},"Failure")," to an ",(0,i.kt)("inlineCode",{parentName:"p"},"EXIT")," node (in the Java SDK, this is accomplished via ",(0,i.kt)("inlineCode",{parentName:"p"},"WorkflowThread::fail()"),"). See the WfRun Lifecycle section for more information."),(0,i.kt)("p",null,"If a ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadRun")," arrives at an ",(0,i.kt)("inlineCode",{parentName:"p"},"EXIT")," node while it still has running child ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadRun"),"s, the parent ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadRun")," will not complete until all of its children have completed or failed. If one of the children threads fail, then the parent ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadRun")," will also fail and throw a ",(0,i.kt)("inlineCode",{parentName:"p"},"CHILD_FAILED")," exception."),(0,i.kt)("h3",{id:"task-node"},(0,i.kt)("inlineCode",{parentName:"h3"},"TASK")," Node"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"TASK")," node is the most common Node type in LittleHorse. As the name implies, the ",(0,i.kt)("inlineCode",{parentName:"p"},"TASK")," node specifies a ",(0,i.kt)("inlineCode",{parentName:"p"},"TaskDef")," to execute when the ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadRun")," arrives at that node. The resulting ",(0,i.kt)("inlineCode",{parentName:"p"},"NodeRun")," schedules a Task Run that must be executed by your Task Worker clients."),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"TASK")," node has a series of input variables which correspond to the input variables of the node's ",(0,i.kt)("inlineCode",{parentName:"p"},"TaskDef"),". These are passed to the Task Worker."),(0,i.kt)("p",null,"The output of a ",(0,i.kt)("inlineCode",{parentName:"p"},"TASK")," node is simply the value returned by the Task Function called by the Task Worker. It may be any arbitrary Variable Value."),(0,i.kt)("p",null,"Every ",(0,i.kt)("inlineCode",{parentName:"p"},"TASK")," node must have a configured timeout. The recommended timeout is 20 seconds; lower or higher values are acceptable. See the Developer Guide for information about how to set Timeouts."),(0,i.kt)("h3",{id:"external_event-node"},(0,i.kt)("inlineCode",{parentName:"h3"},"EXTERNAL_EVENT")," Node"),(0,i.kt)("p",null,"An ",(0,i.kt)("inlineCode",{parentName:"p"},"EXTERNAL_EVENT")," node specifies an ",(0,i.kt)("inlineCode",{parentName:"p"},"ExternalEventDef"),". When a ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadRun")," reaches an ",(0,i.kt)("inlineCode",{parentName:"p"},"EXTERNAL_EVENT")," node, the ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadRun")," will halt until an External Event of the specified ",(0,i.kt)("inlineCode",{parentName:"p"},"ExternalEventDef")," and associated with the correct ",(0,i.kt)("inlineCode",{parentName:"p"},"WfRun")," arrives."),(0,i.kt)("p",null,"Once the External Event arrives, the ",(0,i.kt)("inlineCode",{parentName:"p"},"ExternalEvent"),' object in the API will show that it has been "claimed" by the specific ',(0,i.kt)("inlineCode",{parentName:"p"},"NodeRun"),", and the ",(0,i.kt)("inlineCode",{parentName:"p"},"NodeRun")," will complete. The output of the ",(0,i.kt)("inlineCode",{parentName:"p"},"NodeRun")," is simply the payload of the External Event."),(0,i.kt)("h3",{id:"spawn_thread-node"},(0,i.kt)("inlineCode",{parentName:"h3"},"SPAWN_THREAD")," Node"),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"SPAWN_THREAD")," Node refers to a ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadSpec"),", and when a ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadRun")," arrives at that ",(0,i.kt)("inlineCode",{parentName:"p"},"SPAWN_THREAD")," node, the specified ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadSpec")," is instantiated as a child ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadRun"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"SPAWN_THREAD")," Node optionally specifies input variables for the child ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadRun"),"."),(0,i.kt)("p",null,"The output of the ",(0,i.kt)("inlineCode",{parentName:"p"},"SPAWN_THREAD")," node run is an ",(0,i.kt)("inlineCode",{parentName:"p"},"INT")," Variable Value representing the ID of the resulting Child ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadRun"),"."),(0,i.kt)("h3",{id:"wait_for_thread-node"},(0,i.kt)("inlineCode",{parentName:"h3"},"WAIT_FOR_THREAD")," Node"),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"WAIT_FOR_THREAD")," node takes as input the ID of a specific Child ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadRun"),". When a ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadRun")," arrives at a ",(0,i.kt)("inlineCode",{parentName:"p"},"WAIT_FOR_THREAD")," node, it blocks until the specified Child ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadRun")," also completes."),(0,i.kt)("p",null,"If the Child ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadRun")," fails, then the ",(0,i.kt)("inlineCode",{parentName:"p"},"WAIT_FOR_THREAD")," ",(0,i.kt)("inlineCode",{parentName:"p"},"NODE_RUN")," also fails."),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"WAIT_FOR_THREAD")," node run has no output."),(0,i.kt)("h3",{id:"nop-node"},(0,i.kt)("inlineCode",{parentName:"h3"},"NOP")," Node"),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"NOP")," Node is a no-op. It is used by the SDK's to make control flow simpler to understand."),(0,i.kt)("h3",{id:"sleep-node"},(0,i.kt)("inlineCode",{parentName:"h3"},"SLEEP")," Node"),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"SLEEP")," Node takes as input either a time duration (measured in seconds) or a timestamp, and causes the ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadRun")," to wait until the specified amount of time or timestamp passes."),(0,i.kt)("h2",{id:"node-outputs"},"Node Outputs"),(0,i.kt)("p",null,"Every ",(0,i.kt)("inlineCode",{parentName:"p"},"NodeRun")," produces some output. The output is any ",(0,i.kt)("inlineCode",{parentName:"p"},"VariableValue"),", and can be used to mutate any ",(0,i.kt)("inlineCode",{parentName:"p"},"Variable"),"s in the scope of the ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadRun"),"."),(0,i.kt)("h2",{id:"taskrun-lifecycle"},(0,i.kt)("inlineCode",{parentName:"h2"},"TaskRun")," Lifecycle"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"TaskRun"),' is the "Sub Node Run" for a ',(0,i.kt)("inlineCode",{parentName:"p"},"TASK")," node. The status lifecycle is as follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"STARTING"),": indicates that the ",(0,i.kt)("inlineCode",{parentName:"li"},"ThreadRun")," has arrived at this node, and the Task is scheduled."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"RUNNING"),": indicates that the Task has been dispatched to a Task Worker."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"COMPLETED"),": indicates that the Task has been completed."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ERROR"),": indicates that the Task is timed out, or the Task Worker reported an error.")))}u.isMDXComponent=!0}}]);